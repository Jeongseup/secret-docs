---
description: >-
  An example of how to interact with a Proxy Contract to fetch random numbers
  via IBC, as well as a development playground for applications
---

# Cross-Chain Random Numbers

## Cross-Chain Random Numbers Demo

This documentation serves as a demo on how to **use cross-chain random numbers from Secret Network to another chain via IBC**. The demo repository we will be referencing [can be cloned here](https://github.com/scrtlabs/random-ibc-example).&#x20;

The system consists of two Localsecret chains which simulate Secret Network and a consumer chain (ie another chain, such as Juno for example). In addition, there are two smart contracts:

* **Proxy Contract**: Responsible for fetching the random number from Secret Network via IBC.
* **Consumer Contract**: A contract that represents an application on the consuming chain, which uses the random numbers generated by the proxy contract.

In a real-world scenario, the proxy contract will be deployed once, and there will be many consuming contracts. The proxy contract will produce a _different, non-predictable_ number for each request it receives. You can read more about random numbers on Secret Network in the [documentation](https://docs.scrt.network/secret-network-documentation/development/development-concepts/randomness-api).

### IBC Fundamentals

To connect two CosmWasm contracts over IBC you must establish an IBC channel between them. The IBC channel establishment process uses a four way handshake. Here is a summary of the steps:

1. `OpenInit` Hello chain B, here is information that you can use to verify I am chain A. Do you have information I can use?
2. `OpenTry` Hello chain A, I have verified that you are who you say you are. Here is my verification information.
3. `OpenAck` Hello chain B. Thank you for that information I have verified you are who you say you are. I am now ready to talk.
4. `OpenConfirm` Hello chain A. I am also now ready to talk.

Once the handshake has been completed a channel will be established that the ibc messages may be sent over. In order to do a handshake and receive IBC messages your contract must implement the following entry points (which are implemented in our proxy contract):

1. `ibc_channel_open` - Handles the `OpenInit` and `OpenTry` handshake steps.
2. `ibc_channel_connect` - Handles the `OpenAck` and `OpenConfirm` handshake steps.
3. `ibc_channel_close` - Handles the closing of an IBC channel by the counterparty.
4. `ibc_packet_receive` - Handles receiving IBC packets from the counter-party.
5. `ibc_packet_ack` - Handles ACK messages from the counter-party.&#x20;
6. `ibc_packet_timeout` - Handles packet timeouts.

{% hint style="info" %}
[Here is a great repo](https://github.com/0xekez/cw-ibc-example) to learn more about IBC fundamentals [ðŸŽ‰](https://emojipedia.org/party-popper/)
{% endhint %}

### Contracts

The Proxy Contract provides the [RequestRandom function](https://github.com/scrtlabs/random-ibc-example/blob/5ae0da52469fea0eb390a12dbfb370b03c2592a2/contracts/proxy/src/contract.rs#L73), which allows users to request a random number. The contract then sends the random number via IBC, which can be received using the [RandomResponse function](https://github.com/scrtlabs/random-ibc-example/blob/5ae0da52469fea0eb390a12dbfb370b03c2592a2/contracts/proxy/src/contract.rs#L141). [The Consumer Contract](https://github.com/scrtlabs/random-ibc-example/blob/main/contracts/consumer/src/contract.rs) is an example of how a user can interact with the Proxy Contract to request and receive random numbers.

**Here are the main components of the Proxy Contract:**

* RequestRandom: Requests a random number and specifies the callback information for the response.

```rust
PacketMsg::RequestRandom { job_id, .. } => {

            // Debug statement that prints the current environment variable
            deps.api.debug(&format!("{:?}", env));

            // Extract the random seed from the block environment, unwrapping the Option
            let random = env.block.random.unwrap();

            // Initialize a pseudo-random number generator (Prng) with the random seed and job_id as bytes
            let mut rng = Prng::new(random.as_slice(), job_id.as_bytes());

            // Generate random bytes and encode it to a hexadecimal string
            let rand_for_job = hex::encode(rng.rand_bytes());

            // Create a RandomResponse message with the generated random number and job_id
            let res = PacketMsg::RandomResponse {
                random: rand_for_job,
                job_id,
            };

            // Set the acknowledgement of the response with the binary form of RandomResponse
            response = response.set_ack(to_binary(&res).unwrap());
        }
```

**The main components of the Consumer Contract are:**

* DoSomething: Triggers a request for a random number from the Proxy Contract.

```rust
ExecuteMsg::DoSomething { .. } => {

            // Get the proxy contract information using the helper function get_contract
            let rand_provider = get_contract(deps.storage)?;

            // Create a message requesting a random number. The job_id is set as the current block height
            // and callback is set to None
            let msg = get_random_msg(
                env.clone(),      // Clone of the current environment
                rand_provider,    // The contract address of the random provider
                env.block.height.to_string(), // The block height used as the job ID
                None,             // No specific callback data
            )?;

            // Return a new Response, adding the created message to it
            Ok(Response::new().add_message(msg))
        }
```

* RandomResponse: Receives the random number from the Proxy Contract and stores it in the Consumer Contract's storage.

```rust
ExecuteMsg::RandomResponse { random, job_id, .. } => {

            // Store the random result associated with the current block height using the helper function store_rand_result
            store_rand_result(deps.storage, env.block.height, random.clone())?;

            // Return a new Response, adding two attributes to it: 
            // 1. "random" attribute with the plaintext random number
            // 2. "job_id" attribute with the provided job ID
            Ok(Response::new()
                .add_attribute_plaintext("random", random)
                .add_attribute("job_id", job_id))
        }
```

In this example, the interaction with the proxy is done using callback methods. The consumer requests a random number, and the proxy will call the RandomResponse method of the calling contract once the number is available. This is an example of such an interface, and real-world implementation may differ.

### Build and Run Cross-Chain Contract Demo

To start, [clone down this repo](https://github.com/scrtlabs/random-ibc-example/tree/5ae0da52469fea0eb390a12dbfb370b03c2592a2), which we will be using for the demo.&#x20;

**Build Proxy and Consumer Images**

```
make
```

{% hint style="info" %}
You can view the [`Makefile`](https://github.com/scrtlabs/random-ibc-example/blob/5ae0da52469fea0eb390a12dbfb370b03c2592a2/Makefile) to see what this command is doing behind-the-scenes.&#x20;
{% endhint %}

**Run (Run from the repository's root directory)**

```
docker compose up
```

{% hint style="info" %}
To run this command successfully you must have docker installed and running
{% endhint %}

**Interact with the Consumer Contract**

The consumer contract exposes an interface to display the latest received random number, and request a new one. You can access this web interface via the browser at:

```
http://localhost:8080
```

{% hint style="info" %}
The contract must first be instantiated with docker in order to access the web interface in the browser&#x20;
{% endhint %}

### Summary

This documentation demonstrates the use of cross-chain random numbers from Secret Network to another blockchain via the IBC protocol. The Proxy Contract fetches random numbers from Secret Network via IBC and the Consumer Contract, representative of an application on the consuming chain, utilizes these random numbers. The Proxy Contract provides the `RequestRandom` function, and the random number can be received using the `RandomResponse` function. The Consumer Contract, on the other hand, requests a random number using the `DoSomething` function and stores it in its own storage using the `RandomResponse` function.

#### Use demo as a development playground

In the Consumer Contract, replace the logic with your own application logic [ðŸŽ‰](https://emojipedia.org/party-popper/) (and make sure you re-upload the contract!)&#x20;

Interact with the Proxy Contract to request and receive random numbers using the `RequestRandom` and `RandomResponse` functions.

